1).data
    msg_prompt: .asciiz "Enter a number to check if it's perfect: "
    msg_yes: .asciiz " is a Perfect Number.\n"
    msg_no: .asciiz " is NOT a Perfect Number.\n"
    msg_divisors: .asciiz "Divisors: "
    msg_sum: .asciiz "Sum of proper divisors: "
    comma_space: .asciiz ", "
    newline: .asciiz "\n"

.text
    .globl main
main:
    # Prompt user for input
    li $v0, 4
    la $a0, msg_prompt
    syscall

    li $v0, 5   # Read integer input from user
    syscall
    move $t0, $v0  # Store user input in $t0

    li $t1, 1      # Start divisor from 1
    li $t2, 0      # Sum of proper divisors
    li $t5, 0      # Flag to track first divisor

    # Display divisors message
    li $v0, 4
    la $a0, msg_divisors
    syscall

loop:
    div $t3, $t0, $t1  # Divide number by divisor
    mfhi $t4           # Get remainder

    beq $t4, $zero, add_divisor  # If remainder is zero, add divisor
    
    j next_divisor

add_divisor:
    # Print comma separator if not the first divisor
    beq $t5, $zero, first_divisor
    li $v0, 4
    la $a0, comma_space
    syscall

first_divisor:
    li $t5, 1  # Mark that we have printed at least one divisor

    # Print current divisor
    li $v0, 1
    move $a0, $t1
    syscall

    # Only add to sum if divisor is NOT the number itself
    bne $t1, $t0, sum_divisor
    j next_divisor

sum_divisor:
    add $t2, $t2, $t1  # Sum += proper divisor

next_divisor:
    addi $t1, $t1, 1   # Increment divisor
    bgt $t1, $t0, check_result  # Stop when divisor > number
    j loop

check_result:
    # Print newline after divisor list
    li $v0, 4
    la $a0, newline
    syscall

    # Display sum of proper divisors message
    li $v0, 4
    la $a0, msg_sum
    syscall

    # Print sum of proper divisors
    li $v0, 1
    move $a0, $t2
    syscall

    # Print newline
    li $v0, 4
    la $a0, newline
    syscall

    # Print original number
    li $v0, 1
    move $a0, $t0
    syscall

    # Check if sum == original number
    beq $t2, $t0, perfect
    li $v0, 4          # Print NOT Perfect message
    la $a0, msg_no
    syscall
    j exit

perfect:
    li $v0, 4          # Print Perfect message
    la $a0, msg_yes
    syscall

exit:
    li $v0, 10         # Exit program
    syscall


2)Booths
#include<iostream>
using namespace std;

void add(int a[], int x[], int q);

void complement(int a[], int n) {
   int i;
   int x[8] = { 0 };
   x[0] = 1;
   for (i = 0; i < n; i++) {
      a[i] = (a[i] + 1) % 2;
   }
   add(a, x, n);
}

void add(int ac[], int x[], int q) {
   int i, c = 0;
   for (i = 0; i < q; i++) {
      ac[i] = ac[i] + x[i] + c;
      if (ac[i] > 1) {
         ac[i] = ac[i] % 2;
         c = 1;
      } else {
         c = 0;
      }
   }
}

void ashr(int ac[], int qr[], int &qn, int q) {
   int temp, i;
   temp = ac[0];
   qn = qr[0];
   cout << "\t\tashr\t\t";
   for (i = 0; i < q - 1; i++) {
      ac[i] = ac[i + 1];
      qr[i] = qr[i + 1];
   }
   qr[q - 1] = temp;
}

void display(int ac[], int qr[], int qrn) {
   int i;
   for (i = qrn - 1; i >= 0; i--)
      cout << ac[i];
   cout << " ";
   for (i = qrn - 1; i >= 0; i--)
      cout << qr[i];
}

int main() {
   const int FIXED_BITS = 4;
   int mt[FIXED_BITS], br[FIXED_BITS], qr[FIXED_BITS], ac[FIXED_BITS] = {0};
   int sc = FIXED_BITS, qn = 0, temp = 0;

   cout << "\n--Booth's Multiplication for 4-bit signed binary numbers--\n";
   cout << "Enter 4-bit multiplicand (LSB first, space-separated): ";
   for (int i = FIXED_BITS - 1; i >= 0; i--)
      cin >> br[i];
   for (int i = 0; i < FIXED_BITS; i++)
      mt[i] = br[i];
   complement(mt, FIXED_BITS);

   cout << "Enter 4-bit multiplier (LSB first, space-separated): ";
   for (int i = FIXED_BITS - 1; i >= 0; i--)
      cin >> qr[i];

   cout << "qn\tq[n+1]\t\tBR\t\tAC\tQR\t\tsc\n";
   cout << "\t\t\tinitial\t\t";
   display(ac, qr, FIXED_BITS);
   cout << "\t\t" << sc << "\n";

   while (sc != 0) {
      cout << qr[0] << "\t" << qn;
      if ((qn + qr[0]) == 1) {
         if (temp == 0) {
            add(ac, mt, FIXED_BITS);
            cout << "\t\tsubtracting BR\t";
            for (int i = FIXED_BITS - 1; i >= 0; i--)
               cout << ac[i];
            temp = 1;
         } else if (temp == 1) {
            add(ac, br, FIXED_BITS);
            cout << "\t\tadding BR\t";
            for (int i = FIXED_BITS - 1; i >= 0; i--)
               cout << ac[i];
            temp = 0;
         }
         cout << "\n\t";
         ashr(ac, qr, qn, FIXED_BITS);
      } else {
         ashr(ac, qr, qn, FIXED_BITS);
      }
      display(ac, qr, FIXED_BITS);
      cout << "\t";
      sc--;
      cout << "\t" << sc << "\n";
   }

   cout << "Result = ";
   display(ac, qr, FIXED_BITS);
   cout << "\n";

   // Binary to decimal conversion
   int result[2 * FIXED_BITS];
   for (int i = 0; i < FIXED_BITS; i++)
      result[i] = qr[i];
   for (int i = 0; i < FIXED_BITS; i++)
      result[i + FIXED_BITS] = ac[i];

   bool isNegative = result[2 * FIXED_BITS - 1] == 1;
   if (isNegative) {
      for (int i = 0; i < 2 * FIXED_BITS; i++)
         result[i] = (result[i] + 1) % 2;
      int one[20] = {0};
      one[0] = 1;
      add(result, one, 2 * FIXED_BITS);
   }

   int decimalResult = 0, base = 1;
   for (int i = 0; i < 2 * FIXED_BITS; i++) {
      decimalResult += result[i] * base;
      base *= 2;
   }

   if (isNegative) decimalResult *= -1;
   cout << "Decimal Result = " << decimalResult << endl;

   return 0;
}


3)sequantail 
#include<iostream>
using namespace std;

const int BITS = 4;

void display(int ac[], int qr[]) {
   for (int i = BITS - 1; i >= 0; i--)
      cout << ac[i];
   cout << " ";
   for (int i = BITS - 1; i >= 0; i--)
      cout << qr[i];
   cout << endl;
}

// Adds multiplicand to accumulator
void add(int ac[], int br[]) {
   int carry = 0;
   for (int i = 0; i < BITS; i++) {
      int sum = ac[i] + br[i] + carry;
      ac[i] = sum % 2;
      carry = sum / 2;
   }
}

// Shift AC and QR right
void shiftRight(int ac[], int qr[]) {
   int temp = ac[0];
   for (int i = 0; i < BITS - 1; i++) {
      ac[i] = ac[i + 1];
      qr[i] = qr[i + 1];
   }
   qr[BITS - 1] = temp;
}

void twosComplement(int b[]) {
   for (int i = 0; i < BITS; i++)
      b[i] = (b[i] + 1) % 2;
   int one[BITS] = {1};
   add(b, one);
}

int binaryToDecimal(int result[], bool isNegative) {
   if (isNegative) {
      for (int i = 0; i < 2 * BITS; i++)
         result[i] = (result[i] + 1) % 2;
      int one[2 * BITS] = {1};
      int carry = 0;
      for (int i = 0; i < 2 * BITS; i++) {
         int sum = result[i] + one[i] + carry;
         result[i] = sum % 2;
         carry = sum / 2;
      }
   }

   int decimal = 0, base = 1;
   for (int i = 0; i < 2 * BITS; i++) {
      decimal += result[i] * base;
      base *= 2;
   }
   return isNegative ? -decimal : decimal;
}

int main() {
   int ac[BITS] = {0};
   int qr[BITS], br[BITS], sc = BITS;

   cout << "-- Sequential Multiplication Algorithm (4-bit signed) --\n";
   cout << "Enter 4-bit multiplier (LSB first): ";
   for (int i = BITS - 1; i >= 0; i--) cin >> qr[i];

   cout << "Enter 4-bit multiplicand (LSB first): ";
   for (int i = BITS - 1; i >= 0; i--) cin >> br[i];

   int brCopy[BITS];
   for (int i = 0; i < BITS; i++) brCopy[i] = br[i];

   cout << "\nInitial AC and QR:\n";
   display(ac, qr);

   while (sc--) {
      if (qr[0] == 1) {
         cout << "\nAdding BR to AC:\n";
         add(ac, br);
         display(ac, qr);
      }
      cout << "\nShift Right:\n";
      shiftRight(ac, qr);
      display(ac, qr);
   }

   cout << "\nFinal Binary Result = ";
   for (int i = BITS - 1; i >= 0; i--) cout << ac[i];
   for (int i = BITS - 1; i >= 0; i--) cout << qr[i];
   cout << endl;

   int result[2 * BITS];
   for (int i = 0; i < BITS; i++) result[i] = qr[i];
   for (int i = 0; i < BITS; i++) result[i + BITS] = ac[i];

   bool isNegative = result[2 * BITS - 1] == 1;
   int decimal = binaryToDecimal(result, isNegative);
   cout << "Decimal Result = " << decimal << endl;

   return 0;
}


4)Divisor

#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// Add two binary strings
string add(string A, string B) {
    int carry = 0;
    string sum;

    for (int i = A.length() - 1; i >= 0; i--) {
        int temp = A[i] - '0' + B[i] - '0' + carry;
        sum.push_back('0' + (temp % 2));
        carry = temp / 2;
    }

    reverse(sum.begin(), sum.end());
    return sum;
}

// 2's complement
string complement(string m) {
    string M;
    for (char ch : m)
        M.push_back(ch == '0' ? '1' : '0');
    M = add(M, string(m.length() - 1, '0') + '1');
    return M;
}

// Convert binary string to decimal
int binaryToDecimal(string bin) {
    int result = 0;
    for (char ch : bin) {
        result = result * 2 + (ch - '0');
    }
    return result;
}

// Restoring Division Algorithm
void restoringDivision(string Q, string M, string A) {
    int count = M.length();
    cout << "Initial Values: A:" << A << " Q:" << Q << " M:" << M << endl;

    while (count > 0) {
        cout << "\nStep " << (M.length() - count + 1) << ":\n";
        A = A.substr(1) + Q[0];
        string comp_M = complement(M);
        A = add(A, comp_M);

        cout << "Left Shift and Subtract: A:" << A << endl;
        cout << "A:" << A << " Q:" << Q.substr(1) << "_";

        if (A[0] == '1') {
            Q = Q.substr(1) + '0';
            cout << " - Unsuccessful" << endl;
            A = add(A, M);
            cout << "A:" << A << " Q:" << Q << " - Restoration" << endl;
        } else {
            Q = Q.substr(1) + '1';
            cout << " - Successful" << endl;
            cout << "A:" << A << " Q:" << Q << " - No Restoration" << endl;
        }
        count--;
    }

    cout << "\nFinal Result:\nQuotient (Q): " << Q << "\nRemainder (A): " << A << endl;

    cout << "\nDecimal Output:\n";
    cout << "Quotient (Q) = " << binaryToDecimal(Q) << endl;
    cout << "Remainder (A) = " << binaryToDecimal(A) << endl;
}

int main() {
    string dividend, divisor;

    cout << "Enter 4-bit Dividend (binary): ";
    cin >> dividend;

    cout << "Enter 4-bit Divisor (binary): ";
    cin >> divisor;

    // Basic validation
    if (dividend.length() != 4 || divisor.length() != 4) {
        cout << "Both dividend and divisor must be 4-bit binary numbers.\n";
        return 1;
    }

    string accumulator(4, '0'); // Initially 0000
    restoringDivision(dividend, divisor, accumulator);

    return 0;
}


4)Enter a number: 538453
The number of threes in the given number is: 2
.data
    msg_prompt: .asciiz "Enter a number: "
    count_msg: .asciiz "The number of threes in the given number is: "
    newline: .asciiz "\n"

.text
    .globl main
main:
    # Prompt user for input
    li $v0, 4
    la $a0, msg_prompt
    syscall

    li $v0, 5   # Read user input (integer)
    syscall
    move $t0, $v0  # Store user input in $t0

    li $t1, 3      # Digit to count
    li $t2, 0       # Counter

count_loop:
    beq $t0, $zero, display_result   # If number == 0, stop
    div $t3, $t0, 10     # Get last digit
    mfhi $t4             # Get remainder (last digit)

    beq $t4, $t1, increment_count   # If last digit == 3, count it
    
    j remove_digit

increment_count:
    addi $t2, $t2, 1     # Increment count

remove_digit:
    div $t0, $t0, 10     # Remove last digit
    j count_loop

display_result:
    li $v0, 4
    la $a0, count_msg
    syscall

    li $v0, 1            # Print count
    move $a0, $t2
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    li $v0, 10           # Exit program
    syscall

5)square(function)
.data
     msg1: .asciiz "Enter any number: "            #input message
     msg2: .asciiz "Square of the number is: "     #output message
     
.text
     #input message
      la $a0,msg1
      li $v0,4
      syscall
     
     #Taking integer input
      li $v0,5  
      syscall
      move $t0,$v0
      
     jal Square   #Jump and Link to Square function
     
     #Terminating the program
       li $v0,10
       syscall
Square:
       mul $t1,$t0,$t0
   
       #Output message
        la $a0,msg2
        li $v0,4
        syscall
       
       #Printing square of the number
        move $a0,$t1
        li $v0,1
        syscall
       
       jr $ra

6)Divisor
.data
prompt:     .asciiz "Enter an integer: "
div_msg:    .asciiz "Divisors: "
comma:      .asciiz ", "
newline:    .asciiz "\n"

.text
.globl main

main:
    # Prompt user
    li $v0, 4
    la $a0, prompt
    syscall

    # Read integer
    li $v0, 5
    syscall
    move $a1, $v0       # Save input in $a1 (used as argument to function)

    # Print "Divisors: "
    li $v0, 4
    la $a0, div_msg
    syscall

    # Call function
    jal print_divisors

    # Print newline
    li $v0, 4
    la $a0, newline
    syscall

    # Exit
    li $v0, 10
    syscall

# -------------------------------
# Function: print_divisors
# Input: $a1 = input number
# -------------------------------
print_divisors:
    move $t1, $a1       # $t1 = number
    li $t0, 1           # $t0 = i (counter)
    li $t2, 0           # $t2 = first_flag

div_loop:
    bgt $t0, $t1, end_divs   # while i <= n

    move $t3, $t1       # $t3 = n
    div $t3, $t0
    mfhi $t4            # remainder
    bnez $t4, not_div   # skip if not divisible

    # If not first, print comma
    bnez $t2, print_comma

skip_comma:
    move $a0, $t0       # prepare number to print
    li $v0, 1           # syscall: print integer
    syscall

    li $t2, 1           # mark that at least one divisor printed
    j continue_loop

print_comma:
    li $v0, 4
    la $a0, comma
    syscall
    j skip_comma

not_div:
    # skip

continue_loop:
    addi $t0, $t0, 1
    j div_loop

end_divs:
    jr $ra


7)Prime(function)
.data
    msg_input:      .asciiz "Enter a number: "
    msg_prime:      .asciiz "The number is PRIME.\n"
    msg_not_prime:  .asciiz "The number is NOT PRIME.\n"

.text
.globl main

main:
    # Prompt user for input
    li $v0, 4
    la $a0, msg_input
    syscall

    # Read user input
    li $v0, 5
    syscall
    move $a0, $v0       # Move input number to $a0 (argument for function)

    # Call is_prime function
    jal is_prime

    # Check return value in $v0
    beq $v0, $zero, print_not_prime
    j print_prime

print_not_prime:
    li $v0, 4
    la $a0, msg_not_prime
    syscall
    j exit

print_prime:
    li $v0, 4
    la $a0, msg_prime
    syscall
    j exit

exit:
    li $v0, 10
    syscall

# Function: is_prime
# Input : $a0 = number
# Output: $v0 = 1 (prime), 0 (not prime)

is_prime:
    move $t0, $a0       # $t0 = number
    li $t1, 2           # $t1 = divisor (starts from 2)

    # If number <= 1, not prime
    li $t4, 1
    ble $t0, $t4, not_prime_func

check_loop:
    mul $t5, $t1, $t1   # $t5 = divisor^2
    bgt $t5, $t0, prime_func  # if divisor^2 > number, it's prime

    div $t0, $t1        # divide number by divisor
    mfhi $t2            # get remainder

    beq $t2, $zero, not_prime_func  # divisible => not prime

    addi $t1, $t1, 1    # divisor++
    j check_loop

not_prime_func:
    li $v0, 0
    jr $ra

prime_func:
    li $v0, 1
    jr $ra

8)Reverse
.data
    prompt:         .asciiz "Enter a number: "
    resultMsg:      .asciiz "Reversed number: "
    inputBuffer:    .space 20
    reversedBuffer: .space 20

.text
.globl main

main:
    # Prompt for input
    li $v0, 4
    la $a0, prompt
    syscall

    # Read string input
    li $v0, 8
    la $a0, inputBuffer
    li $a1, 20
    syscall

    # Call reverse_string(inputBuffer, reversedBuffer)
    la $a0, inputBuffer      # arg1 = input string
    la $a1, reversedBuffer   # arg2 = output (reversed) string
    jal reverse_string       # call function

    # Print result
    li $v0, 4
    la $a0, resultMsg
    syscall

    li $v0, 4
    la $a0, reversedBuffer
    syscall

    # Exit
    li $v0, 10
    syscall

# --------------------------------------------
# Procedure: reverse_string
# Arguments:
#   $a0 = address of input string
#   $a1 = address of output buffer
# --------------------------------------------
reverse_string:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    # Find length of input string
    move $t0, $a0          # $t0 = input pointer
    li $t1, 0              # $t1 = length counter

count_loop:
    lb $t2, 0($t0)
    beq $t2, 10, done_count   # Stop at newline
    beqz $t2, done_count      # Or null character
    addi $t0, $t0, 1
    addi $t1, $t1, 1
    j count_loop

done_count:
    # $t1 = length of input (excluding newline)
    add $t3, $a0, $t1     # $t3 = pointer to end of input
    move $t4, $a1         # $t4 = output pointer

reverse_loop:
    addi $t3, $t3, -1
    lb $t5, 0($t3)
    sb $t5, 0($t4)
    addi $t4, $t4, 1
    addi $t1, $t1, -1
    bgtz $t1, reverse_loop

    # Null-terminate output string
    li $t6, 0
    sb $t6, 0($t4)

    # Restore return address and return
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra


9)sum even and odd(1-20)
.data
    evenMsg:   .asciiz "Sum of even numbers: "
    oddMsg:    .asciiz "Sum of odd numbers: "
    
.text
.globl main

main:
    li $t0, 1          # i = 1
    li $t1, 0          # even sum
    li $t2, 0          # odd sum

loop:
    bgt $t0, 20, done  # if i > 20, exit loop

    # check if even: if i % 2 == 0
    rem $t3, $t0, 2
    beq $t3, $zero, add_even

    # else it's odd
    add $t2, $t2, $t0   # odd sum += i
    j next

add_even:
    add $t1, $t1, $t0   # even sum += i

next:
    addi $t0, $t0, 1    # i++
    j loop

done:
    # print even sum
    li $v0, 4
    la $a0, evenMsg
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    # print newline
    li $v0, 11
    li $a0, 10
    syscall

    # print odd sum
    li $v0, 4
    la $a0, oddMsg
    syscall

    li $v0, 1
    move $a0, $t2
    syscall

    # exit
    li $v0, 10
    syscall


10)Length
.data
    prompt: .asciiz "Enter an integer: "
    result: .asciiz "Number of digits: "
    newline: .asciiz "\n"
    input:  .space 20

.text
.globl main

main:
    # Prompt
    li $v0, 4
    la $a0, prompt
    syscall

    # Read string
    li $v0, 8
    la $a0, input
    li $a1, 20
    syscall

    # Call function to count digits
    la $a0, input
    jal count_digits_string
    move $t1, $v0      # save result

    # Print message
    li $v0, 4
    la $a0, result
    syscall

    # Print digit count
    li $v0, 1
    move $a0, $t1
    syscall

    # Newline
    li $v0, 4
    la $a0, newline
    syscall

    li $v0, 10
    syscall

# Function: count_digits_string
# Input:  $a0 = address of string
# Output: $v0 = digit count
count_digits_string:
    li $t0, 0          # count
count_loop:
    lb $t1, 0($a0)     # load byte
    beq $t1, 10, done  # stop at newline (Enter key)
    beqz $t1, done     # null terminator
    addi $t0, $t0, 1
    addi $a0, $a0, 1
    j count_loop

done:
    move $v0, $t0
    jr $ra
 

11)even number array
.data
array: .space 2000            # 2000 bytes space for integer array
space: .asciiz " "
howMany: .asciiz "Enter the number of integers: "
inputMsg: .asciiz "Enter the elements of array :-\n"
outputMsg: .asciiz "Even numbers in the array: "

.text
.globl main

main:
    # print prompt for number of integers
    li $v0, 4
    la $a0, howMany
    syscall

    # read number of integers (n)
    li $v0, 5
    syscall
    move $s1, $v0          # s1 = n

    mul $s1, $s1, 4        # multiply by 4 to convert count to bytes for addressing

    # print input message
    li $v0, 4
    la $a0, inputMsg
    syscall

    addi $s0, $zero, 0     # s0 = 0 (offset/index in bytes)

inputLoop:
    beq $s0, $s1, output   # if offset == n*4, done input

    # take input integer
    li $v0, 5
    syscall
    move $t1, $v0

    # store input in array at offset s0
    sw $t1, array($s0)

    addi $s0, $s0, 4       # s0 += 4 (next int offset)
    j inputLoop

output:
    # print output message
    li $v0, 4
    la $a0, outputMsg
    syscall

    addi $s0, $zero, 0     # reset index for printing

printLoop:
    beq $s0, $s1, exit     # if offset == n*4, done printing

    lw $t4, array($s0)     # load word from array

    # check if even: (num % 2 == 0) using bitwise AND
    andi $t5, $t4, 1       # $t5 = $t4 & 1 (lowest bit)
    bne  $t5, $zero, skip_print

    # print integer (even number)
    li $v0, 1
    move $a0, $t4
    syscall

    # print space
    li $v0, 4
    la $a0, space
    syscall

skip_print:
    addi $s0, $s0, 4       # s0 += 4 (next element)
    j printLoop

exit:
    # exit program
    li $v0, 10
    syscall

12)arry-print
.data
	array: .space 2000 #2000 bytes
	space: .asciiz " "
	howMany: .asciiz "Enter the number of integer less than 500: "
	inputMsg: .asciiz "Enter the element of array :-\n"
	outputMsg: .asciiz "Array: "
.text
main:
	#print the string stored in howMany
	li $v0, 4
	la $a0, howMany
	syscall
	
	#Define the number of integers that should be input
	li $v0, 5
	syscall
	move $s1, $v0 #s1=5 integers
	
	mul $s1,$s1,4 # s1=20 bytes

	#print the string stored in howMany
	li $v0, 4
	la $a0, inputMsg
	syscall
	addi $s0, $zero, 0

inputLoop:
	beq $s0, $s1, output
	#take input form user
	li $v0, 5
	syscall
	move $t1, $v0
	
#store value in array
	sw $t1, array($s0) # array[0]=$t1    0,4,8,12,16,20
	addi $s0, $s0,4
	j inputLoop
output:
	li $v0, 4
	la $a0, outputMsg
	syscall
	
	addi $s0,$zero,0
printLoop:
	beq $s0, $s1, exit
	lw $t4, array($s0)
	#print the instant array position value
	li $v0, 1 #printing an integer
	move $a0, $t4
	syscall
	#print a space after a number
	li $v0, 4
	la $a0, space
	syscall
	#increment like i++
	addi, $s0, $s0,4
	j printLoop
exit:
	li $v0, 10
	syscall

13)odd
.data
array: .space 2000            # 2000 bytes space for integer array
space: .asciiz " "
howMany: .asciiz "Enter the number of integers: "
inputMsg: .asciiz "Enter the elements of array :-\n"
outputMsg: .asciiz "Odd numbers in the array: "

.text
.globl main

main:
    # print prompt for number of integers
    li $v0, 4
    la $a0, howMany
    syscall

    # read number of integers (n)
    li $v0, 5
    syscall
    move $s1, $v0          # s1 = n

    mul $s1, $s1, 4        # multiply by 4 to convert count to bytes for addressing

    # print input message
    li $v0, 4
    la $a0, inputMsg
    syscall

    addi $s0, $zero, 0     # s0 = 0 (offset/index in bytes)

inputLoop:
    beq $s0, $s1, output   # if offset == n*4, done input

    # take input integer
    li $v0, 5
    syscall
    move $t1, $v0

    # store input in array at offset s0
    sw $t1, array($s0)

    addi $s0, $s0, 4       # s0 += 4 (next int offset)
    j inputLoop

output:
    # print output message
    li $v0, 4
    la $a0, outputMsg
    syscall

    addi $s0, $zero, 0     # reset index for printing

printLoop:
    beq $s0, $s1, exit     # if offset == n*4, done printing

    lw $t4, array($s0)     # load word from array

    # check if odd: (num % 2 == 1) using bitwise AND
    andi $t5, $t4, 1       # $t5 = $t4 & 1 (lowest bit)
    beq $t5, $zero, skip_print  # if lowest bit == 0, skip (means even)

    # print integer (odd number)
    li $v0, 1
    move $a0, $t4
    syscall

    # print space
    li $v0, 4
    la $a0, space
    syscall

skip_print:
    addi $s0, $s0, 4       # s0 += 4 (next element)
    j printLoop

exit:
    # exit program
    li $v0, 10
    syscall


14)odd+count
.data
array: .space 2000            # 2000 bytes space for integer array
space: .asciiz " "
howMany: .asciiz "Enter the number of integers: "
inputMsg: .asciiz "Enter the elements of array :-\n"
outputMsg: .asciiz "Odd numbers in the array: "
countMsg: .asciiz "\nTotal odd numbers: "

.text
.globl main

main:
    # print prompt for number of integers
    li $v0, 4
    la $a0, howMany
    syscall

    # read number of integers (n)
    li $v0, 5
    syscall
    move $s1, $v0          # s1 = n

    mul $s1, $s1, 4        # convert n to bytes (for offset)

    # print input message
    li $v0, 4
    la $a0, inputMsg
    syscall

    addi $s0, $zero, 0     # offset = 0

inputLoop:
    beq $s0, $s1, output   # if offset == n*4, done input

    # input integer
    li $v0, 5
    syscall
    move $t1, $v0

    # store in array
    sw $t1, array($s0)

    addi $s0, $s0, 4       # offset += 4
    j inputLoop

output:
    # print odd numbers message
    li $v0, 4
    la $a0, outputMsg
    syscall

    addi $s0, $zero, 0     # offset = 0
    addi $t6, $zero, 0     # t6 = odd count = 0

printLoop:
    beq $s0, $s1, printCount  # if offset == n*4, done printing

    lw $t4, array($s0)

    # check odd
    andi $t5, $t4, 1
    beq $t5, $zero, skip_print

    # print odd number
    li $v0, 1
    move $a0, $t4
    syscall

    # print space
    li $v0, 4
    la $a0, space
    syscall

    # increment odd count
    addi $t6, $t6, 1

skip_print:
    addi $s0, $s0, 4
    j printLoop

printCount:
    # print newline for neatness
    li $v0, 4
    la $a0, space
    syscall

    # print total odd numbers message
    li $v0, 4
    la $a0, countMsg
    syscall

    # print odd count (t6)
    li $v0, 1
    move $a0, $t6
    syscall

exit:
    li $v0, 10
    syscall

15)Avg
.data
array:      .space 400       # 100 integers space
prompt_n:   .asciiz "Enter number of elements: "
prompt_el:  .asciiz "Enter array elements:\n"
msg_sum:    .asciiz "Sum = "
msg_avg:    .asciiz "Average = "

.text
.globl main

main:
    # Prompt for n
    li $v0, 4
    la $a0, prompt_n
    syscall

    # Read n (number of elements)
    li $v0, 5
    syscall
    move $s1, $v0          # s1 = n

    # Prompt for elements
    li $v0, 4
    la $a0, prompt_el
    syscall

    li $s0, 0              # index = 0
input_loop:
    beq $s0, $s1, calc_sum

    # Read one integer
    li $v0, 5
    syscall
    move $t0, $v0

    sll $t1, $s0, 2        # offset = index*4
    sw $t0, array($t1)

    addi $s0, $s0, 1
    j input_loop

calc_sum:
    li $s0, 0
    li $t2, 0              # sum = 0

sum_loop:
    beq $s0, $s1, print_sum_avg

    sll $t1, $s0, 2
    lw $t0, array($t1)
    addu $t2, $t2, $t0

    addi $s0, $s0, 1
    j sum_loop

print_sum_avg:
    # print sum message
    li $v0, 4
    la $a0, msg_sum
    syscall

    # print sum integer
    li $v0, 1
    move $a0, $t2
    syscall

    # print newline
    li $v0, 11
    li $a0, 10
    syscall

    # Convert sum (int) to float in $f12
    mtc1 $t2, $f0           # move sum to $f0 (int)
    cvt.s.w $f12, $f0       # convert int to float in $f12

    # Convert n (int) to float in $f14
    mtc1 $s1, $f2
    cvt.s.w $f14, $f2

    # floating point division: $f12 = sum(float) / n(float)
    div.s $f12, $f12, $f14

    # print avg message
    li $v0, 4
    la $a0, msg_avg
    syscall

    # print average (float) in $f12
    mov.s $f0, $f12
    li $v0, 2
    syscall

    # print newline
    li $v0, 11
    li $a0, 10
    syscall

    # exit
    li $v0, 10
    syscall

16) swap
.data
num1_msg: .asciiz "Enter first number: "
num2_msg: .asciiz "Enter second number: "
after_first_msg: .asciiz "After swap first number: "
after_second_msg: .asciiz " after swap second number "
newline: .asciiz "\n"

.text
.globl main

main:
    # Read first number
    li $v0, 4
    la $a0, num1_msg
    syscall

    li $v0, 5
    syscall
    move $s0, $v0        # num1 in $s0

    # Read second number
    li $v0, 4
    la $a0, num2_msg
    syscall

    li $v0, 5
    syscall
    move $s1, $v0        # num2 in $s1

    # Call swap function
    move $a0, $s0
    move $a1, $s1
    jal swap_numbers

    move $s0, $v0        # swapped first number
    move $s1, $v1        # swapped second number

    # Print "After swap first number: "
    li $v0, 4
    la $a0, after_first_msg
    syscall

    # Print swapped first number
    li $v0, 1
    move $a0, $s0
    syscall

    # Print " after swap second number "
    li $v0, 4
    la $a0, after_second_msg
    syscall

    # Print swapped second number
    li $v0, 1
    move $a0, $s1
    syscall

    # Print newline
    li $v0, 4
    la $a0, newline
    syscall

    # Exit
    li $v0, 10
    syscall

# Swap function: swaps $a0 and $a1, returns swapped values in $v0 and $v1
swap_numbers:
    addi $sp, $sp, -8
    sw $ra, 4($sp)
    sw $s0, 0($sp)

    move $s0, $a0

    move $v0, $a1
    move $v1, $s0

    lw $ra, 4($sp)
    lw $s0, 0($sp)
    addi $sp, $sp, 8
    jr $ra


17)factorial
.data
prompt: .asciiz "Enter a number: "
resultMsg: .asciiz "Factorial = "

.text
.globl main

main:
    # Print prompt
    li $v0, 4
    la $a0, prompt
    syscall

    # Read integer input
    li $v0, 5
    syscall
    move $a0, $v0  # Store input in $a0

    # Check for negative input (factorial is undefined for negative numbers)
    bltz $a0, exit

    # Call factorial function
    jal factorial
    move $s1, $v0  # Store result in $s1

    # Print result message
    li $v0, 4
    la $a0, resultMsg
    syscall

    # Print factorial value
    li $v0, 1
    move $a0, $s1
    syscall

exit:
    # Exit program
    li $v0, 10
    syscall


# Function: factorial
# Arguments:
#   $a0 = input number
# Returns:
#   $v0 = factorial result
factorial:
    addi $sp, $sp, -8       # Allocate stack space
    sw $ra, 4($sp)          # Save return address
    sw $a0, 0($sp)          # Save input number

    li $v0, 1               # Base case: factorial(0) = 1
    blez $a0, end_factorial # If input <= 0, return 1

    # Recursive case: n * factorial(n - 1)
    addi $a0, $a0, -1       # Decrement n
    jal factorial           # Recursive call
    lw $a0, 0($sp)          # Restore original input
    mul $v0, $a0, $v0       # Multiply n * factorial(n - 1)

end_factorial:
    lw $ra, 4($sp)          # Restore return address
    addi $sp, $sp, 8        # Restore stack
    jr $ra                  # Return


18)Palindrom
.data
msg: .asciiz "Enter any number: "
yesMsg: .asciiz "This is a palindrome number.\n"
noMsg: .asciiz "This is not a palindrome number.\n"

.text
.globl main

main:
    # Print message prompt
    li $v0, 4
    la $a0, msg
    syscall

    # Read integer input
    li $v0, 5
    syscall
    move $a0, $v0  # Store input in $a0

    # Call check_palindrome function
    jal check_palindrome
    move $t5, $v0  # Store result in $t5

    # Print corresponding result message
    li $v0, 4
    la $a0, yesMsg
    beq $t5, 1, printResult  # If palindrome, print "Yes"
    
    la $a0, noMsg            # Otherwise, print "No"

printResult:
    syscall

exit:
    # Exit program
    li $v0, 10
    syscall

# Function: check_palindrome
# Arguments:
#   $a0 = input number
# Returns:
#   $v0 = 1 (if palindrome), 0 (if not palindrome)
check_palindrome:
    addi $sp, $sp, -12     # Allocate stack space
    sw $ra, 8($sp)         # Save return address
    sw $a0, 4($sp)         # Save original input
    sw $zero, 0($sp)       # Initialize reversed number ($t4)

    move $t1, $a0          # Copy input to process reversing
    li $t4, 0              # Initialize reversed number

reverseLoop:
    beq $t1, $zero, compare  # If input is fully processed, check result

    rem $t3, $t1, 10        # Get last digit
    mul $t4, $t4, 10        # Shift previous digits left
    add $t4, $t4, $t3       # Append last digit
    div $t1, $t1, 10        # Remove last digit

    j reverseLoop           # Continue reversing

compare:
    lw $t1, 4($sp)          # Restore original input
    beq $t1, $t4, palindrome # If original == reversed, set return value to 1

    li $v0, 0               # Not a palindrome
    j returnFunction

palindrome:
    li $v0, 1               # It is a palindrome

returnFunction:
    lw $ra, 8($sp)          # Restore return address
    addi $sp, $sp, 12       # Restore stack
    jr $ra                  # Return

19)Fibonnaci
.data
msg: .asciiz "Enter the number of terms: "
resultMsg: .asciiz "Fibonacci Sequence: "
space: .asciiz " "

.text
.globl main

main:
    # Print prompt message
    li $v0, 4
    la $a0, msg
    syscall

    # Read number of terms
    li $v0, 5
    syscall
    move $s1, $v0          # Store count in $s1

    # Validate input
    blez $s1, exit         # If input <= 0, exit program

    # Print result message
    li $v0, 4
    la $a0, resultMsg
    syscall

    # Initialize Fibonacci variables
    li $t0, 0              # First term
    li $t1, 1              # Second term

    # Print first term
    li $v0, 1
    move $a0, $t0
    syscall

    # Print space
    li $v0, 4
    la $a0, space
    syscall

    # Check if only one term needed
    beq $s1, 1, exit

    # Print second term
    li $v0, 1
    move $a0, $t1
    syscall

    # Print space
    li $v0, 4
    la $a0, space
    syscall

    # Loop to calculate Fibonacci sequence
    li $s0, 2              # Start index at 2
fiboLoop:
    beq $s0, $s1, exit     # If count reached, exit

    add $t2, $t0, $t1      # Next Fibonacci term
    move $t0, $t1          # Shift values
    move $t1, $t2

    # Print next term
    li $v0, 1
    move $a0, $t2
    syscall

    # Print space
    li $v0, 4
    la $a0, space
    syscall

    addi $s0, $s0, 1       # Increment count
    j fiboLoop

exit:
    # Exit program
    li $v0, 10
    syscall

20)Harshad number
.data
msg: .asciiz "Enter a number: "
yesMsg: .asciiz "It is a Harshad number.\n"
noMsg: .asciiz "It is not a Harshad number.\n"

.text
.globl main

main:
    # Print prompt message
    li $v0, 4
    la $a0, msg
    syscall

    # Read integer input
    li $v0, 5
    syscall
    move $a0, $v0  # Store input in $a0

    # Validate input (must be positive)
    blez $a0, exit # If input ≤ 0, exit program

    # Call harshad_check function
    jal harshad_check
    move $t5, $v0  # Store result in $t5

    # Print corresponding result message
    li $v0, 4
    la $a0, yesMsg
    beq $t5, 1, printResult  # If Harshad number, print "Yes"
    
    la $a0, noMsg            # Otherwise, print "No"

printResult:
    syscall

exit:
    # Exit program
    li $v0, 10
    syscall


# Function: harshad_check
# Arguments:
#   $a0 = input number
# Returns:
#   $v0 = 1 (if Harshad number), 0 (if not)

harshad_check:
    addi $sp, $sp, -12      # Allocate stack space
    sw $ra, 8($sp)          # Save return address
    sw $a0, 4($sp)          # Save original input
    sw $zero, 0($sp)        # Initialize sum of digits ($t4)

    move $t1, $a0           # Copy input to process sum
    li $t4, 0               # Initialize sum of digits

sumLoop:
    beq $t1, $zero, checkDivision  # If all digits are processed, check result

    rem $t3, $t1, 10        # Get last digit
    add $t4, $t4, $t3       # Add digit to sum
    div $t1, $t1, 10        # Remove last digit

    j sumLoop               # Continue summing digits

checkDivision:
    lw $t1, 4($sp)          # Restore original input
    rem $t2, $t1, $t4       # Compute original % sum of digits

    beq $t2, $zero, isHarshad  # If divisible, set return value to 1

    li $v0, 0               # Not a Harshad number
    j returnFunction

isHarshad:
    li $v0, 1               # It is a Harshad number

returnFunction:
    lw $ra, 8($sp)          # Restore return address
    addi $sp, $sp, 12       # Restore stack
    jr $ra                  # Return


21)Abundant_number
.data
msg: .asciiz "Enter a number: "
yesMsg: .asciiz "It is an abundant number.\n"
noMsg: .asciiz "It is not an abundant number.\n"

.text
.globl main

main:
    # Print prompt message
    li $v0, 4
    la $a0, msg
    syscall

    # Read integer input
    li $v0, 5
    syscall
    move $a0, $v0  # Store input in $a0

    # Validate input (must be positive)
    blez $a0, exit # If input ≤ 0, exit program

    # Call abundant_check function
    jal abundant_check
    move $t5, $v0  # Store result in $t5

    # Print corresponding result message
    li $v0, 4
    la $a0, yesMsg
    beq $t5, 1, printResult  # If abundant number, print "Yes"
    
    la $a0, noMsg            # Otherwise, print "No"

printResult:
    syscall

exit:
    # Exit program
    li $v0, 10
    syscall


# Function: abundant_check
# Arguments:
#   $a0 = input number
# Returns:
#   $v0 = 1 (if abundant number), 0 (if not)

abundant_check:
    addi $sp, $sp, -12      # Allocate stack space
    sw $ra, 8($sp)          # Save return address
    sw $a0, 4($sp)          # Save original input
    sw $zero, 0($sp)        # Initialize sum of divisors ($t4)

    li $t1, 1               # Start divisor at 1
    li $t4, 0               # Initialize sum of divisors

divisorLoop:
    beq $t1, $a0, checkAbundance  # If all divisors checked, verify result

    rem $t3, $a0, $t1       # Check if divisible
    bne $t3, $zero, skipDivisor # If not a divisor, skip

    add $t4, $t4, $t1       # Add divisor to sum

skipDivisor:
    addi $t1, $t1, 1        # Increment divisor
    j divisorLoop           # Continue checking

checkAbundance:
    lw $t1, 4($sp)          # Restore original input
    bgt $t4, $t1, isAbundant  # If sum of divisors > number, set return value to 1

    li $v0, 0               # Not an abundant number
    j returnFunction

isAbundant:
    li $v0, 1               # It is an abundant number

returnFunction:
    lw $ra, 8($sp)          # Restore return address
    addi $sp, $sp, 12       # Restore stack
    jr $ra                  # Return

22)Max
.data
    prompt1: .asciiz "Enter the number of integers (less than 500): "
    prompt2: .asciiz "Enter elements one by one:\n"
    max_msg: .asciiz "Maximum number: "
    arr: .space 2000  # Reserve space for 500 integers

.text
    .globl main

main:
    # Prompt for number of elements
    li $v0, 4
    la $a0, prompt1
    syscall
    
    # Read user input for array size
    li $v0, 5
    syscall
    move $t0, $v0  # Store number of elements in $t0

    # Prompt user for elements
    li $v0, 4
    la $a0, prompt2
    syscall
    
    # Read elements into array
    la $t1, arr  # Base address of array
    li $t2, 0    # Counter

input_loop:
    bge $t2, $t0, find_max_func  # If counter >= size, call max function

    li $v0, 5
    syscall
    sw $v0, 0($t1)  # Store input into array
    addi $t1, $t1, 4  # Move to next array position
    addi $t2, $t2, 1  # Increment counter
    j input_loop

find_max_func:
    la $a0, arr  # Pass array base address
    move $a1, $t0  # Pass number of elements
    jal find_max  # Call function
    move $t3, $v0  # Store returned max value

    # Print "Maximum number: "
    li $v0, 4
    la $a0, max_msg
    syscall

    # Print max number
    li $v0, 1
    move $a0, $t3
    syscall
    
    # Exit program
    li $v0, 10
    syscall

find_max:
    move $t4, $a0  # Load array base address
    move $t5, $a1  # Load size
    lw $t6, 0($t4)  # First element as initial max
    li $t7, 1  # Loop counter

max_loop:
    bge $t7, $t5, return_max  # If counter >= size, return max

    lw $t8, 4($t4)  # Load next element
    bgt $t8, $t6, update_max  # Compare with current max
    j continue_loop

update_max:
    move $t6, $t8  # Update max value

continue_loop:
    addi $t4, $t4, 4  # Move to next array element
    addi $t7, $t7, 1  # Increment counter
    j max_loop

return_max:
    move $v0, $t6  # Return max value
    jr $ra
23)min(fun
.data
    prompt1: .asciiz "Enter the number of integers (less than 500): "
    prompt2: .asciiz "Enter elements one by one:\n"
    min_msg: .asciiz "Minimum number: "
    arr: .space 2000  # Reserve space for 500 integers

.text
    .globl main

main:
    # Prompt for number of elements
    li $v0, 4
    la $a0, prompt1
    syscall
    
    # Read user input for array size
    li $v0, 5
    syscall
    move $t0, $v0  # Store number of elements in $t0

    # Prompt user for elements
    li $v0, 4
    la $a0, prompt2
    syscall
    
    # Read elements into array
    la $t1, arr  # Base address of array
    li $t2, 0    # Counter

input_loop:
    bge $t2, $t0, find_min_func  # If counter >= size, call min function

    li $v0, 5
    syscall
    sw $v0, 0($t1)  # Store input into array
    addi $t1, $t1, 4  # Move to next array position
    addi $t2, $t2, 1  # Increment counter
    j input_loop

find_min_func:
    la $a0, arr  # Pass array base address
    move $a1, $t0  # Pass number of elements
    jal find_min  # Call function
    move $t3, $v0  # Store returned min value

    # Print "Minimum number: "
    li $v0, 4
    la $a0, min_msg
    syscall

    # Print min number
    li $v0, 1
    move $a0, $t3
    syscall
    
    # Exit program
    li $v0, 10
    syscall

find_min:
    move $t4, $a0  # Load array base address
    move $t5, $a1  # Load size
    lw $t6, 0($t4)  # First element as initial min
    li $t7, 1  # Loop counter

min_loop:
    bge $t7, $t5, return_min  # If counter >= size, return min

    lw $t8, 4($t4)  # Load next element
    blt $t8, $t6, update_min  # Compare with current min
    j continue_loop

update_min:
    move $t6, $t8  # Update min value

continue_loop:
    addi $t4, $t4, 4  # Move to next array element
    addi $t7, $t7, 1  # Increment counter
    j min_loop

return_min:
    move $v0, $t6  # Return min value
    jr $ra

 
