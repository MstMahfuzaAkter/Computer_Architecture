1).data
    msg_prompt: .asciiz "Enter a number to check if it's perfect: "
    msg_yes: .asciiz " is a Perfect Number.\n"
    msg_no: .asciiz " is NOT a Perfect Number.\n"
    msg_divisors: .asciiz "Divisors: "
    msg_sum: .asciiz "Sum of proper divisors: "
    comma_space: .asciiz ", "
    newline: .asciiz "\n"

.text
    .globl main
main:
    # Prompt user for input
    li $v0, 4
    la $a0, msg_prompt
    syscall

    li $v0, 5   # Read integer input from user
    syscall
    move $t0, $v0  # Store user input in $t0

    li $t1, 1      # Start divisor from 1
    li $t2, 0      # Sum of proper divisors
    li $t5, 0      # Flag to track first divisor

    # Display divisors message
    li $v0, 4
    la $a0, msg_divisors
    syscall

loop:
    div $t3, $t0, $t1  # Divide number by divisor
    mfhi $t4           # Get remainder

    beq $t4, $zero, add_divisor  # If remainder is zero, add divisor
    
    j next_divisor

add_divisor:
    # Print comma separator if not the first divisor
    beq $t5, $zero, first_divisor
    li $v0, 4
    la $a0, comma_space
    syscall

first_divisor:
    li $t5, 1  # Mark that we have printed at least one divisor

    # Print current divisor
    li $v0, 1
    move $a0, $t1
    syscall

    # Only add to sum if divisor is NOT the number itself
    bne $t1, $t0, sum_divisor
    j next_divisor

sum_divisor:
    add $t2, $t2, $t1  # Sum += proper divisor

next_divisor:
    addi $t1, $t1, 1   # Increment divisor
    bgt $t1, $t0, check_result  # Stop when divisor > number
    j loop

check_result:
    # Print newline after divisor list
    li $v0, 4
    la $a0, newline
    syscall

    # Display sum of proper divisors message
    li $v0, 4
    la $a0, msg_sum
    syscall

    # Print sum of proper divisors
    li $v0, 1
    move $a0, $t2
    syscall

    # Print newline
    li $v0, 4
    la $a0, newline
    syscall

    # Print original number
    li $v0, 1
    move $a0, $t0
    syscall

    # Check if sum == original number
    beq $t2, $t0, perfect
    li $v0, 4          # Print NOT Perfect message
    la $a0, msg_no
    syscall
    j exit

perfect:
    li $v0, 4          # Print Perfect message
    la $a0, msg_yes
    syscall

exit:
    li $v0, 10         # Exit program
    syscall


2)Booths
#include <iostream>
#include <bitset>

using namespace std;

// Booth's Algorithm for 4-bit multiplication
int boothMultiplication(int m, int q, int bit_size) {
    int a = 0, q1 = 0;
    int count = bit_size;

    cout << "\nBooth’s Algorithm Steps:\n";
    cout << "A\tQ\tQ1\tOperation\n";

    while (count--) {
        cout << bitset<4>(a) << "\t" << bitset<4>(q) << "\t" << q1 << "\t";

        if ((q & 1) == 1 && q1 == 0) {
            a -= m;  // Subtract multiplicand
            cout << "A = A - M\n";
        } else if ((q & 1) == 0 && q1 == 1) {
            a += m;  // Add multiplicand
            cout << "A = A + M\n";
        } else {
            cout << "Shift Right\n";
        }

        // Right shift A and Q together
        q1 = q & 1;
        q = (q >> 1) | ((a & 1) << (bit_size - 1));
        a >>= 1;
    }

    return (a << bit_size) + q;  // Combine A and Q for final product
}

// Convert binary string to integer (4-bit handling)
int binaryToInt(const string& binary) {
    return bitset<4>(binary).to_ulong();
}

// Convert integer to binary string (8-bit output)
string intToBinary(int num, int bit_size) {
    return bitset<8>(num).to_string().substr(8 - bit_size, bit_size);
}

int main() {
    string bin_m, bin_q;
    cout << "Enter multiplicand (4-bit binary): ";
    cin >> bin_m;
    cout << "Enter multiplier (4-bit binary): ";
    cin >> bin_q;

    int m = binaryToInt(bin_m);
    int q = binaryToInt(bin_q);
    int product = boothMultiplication(m, q, 4);  // Using 4-bit representation

    cout << "\nInteger Product: " << product << endl;
    cout << "Binary Product: " << intToBinary(product, 8) << endl;

    return 0;
}

3)sequantail 
#include <iostream>
#include <bitset>

using namespace std;

// Function for Sequential Multiplication (Bitwise Addition)
int sequentialMultiplication(int multiplicand, int multiplier) {
    int product = 0;

    while (multiplier > 0) {
        if (multiplier & 1) {
            product += multiplicand;
        }
        multiplicand <<= 1;
        multiplier >>= 1;
    }

    return product;
}

// Convert binary string to integer
int binaryToInt(const string& binary) {
    return bitset<4>(binary).to_ulong();
}

// Convert integer to binary string
string intToBinary(int num, int bit_size) {
    return bitset<8>(num).to_string().substr(8 - bit_size, bit_size);
}

int main() {
    string bin_m, bin_q;

    cout << "Enter multiplicand (4-bit binary): ";
    cin >> bin_m;
    cout << "Enter multiplier (4-bit binary): ";
    cin >> bin_q;

    int m = binaryToInt(bin_m);
    int q = binaryToInt(bin_q);

    int product = sequentialMultiplication(m, q);

    cout << "\nInteger Product: " << product << endl;
    cout << "Binary Product: " << intToBinary(product, 8) << endl;

    return 0;
}

4)Divisor

#include <iostream>
#include <bitset>

using namespace std;

// Function to perform binary division
pair<int, int> binaryDivision(int dividend, int divisor) {
    if (divisor == 0) {
        cerr << "Error: Division by zero!" << endl;
        return make_pair(0, 0);
    }

    int quotient = 0;
    int remainder = dividend;

    while (remainder >= divisor) {
        remainder -= divisor;
        quotient++;
    }

    return make_pair(quotient, remainder);
}

// Convert binary string to integer
int binaryToInt(const string& binary) {
    return bitset<8>(binary).to_ulong();
}

// Convert integer to binary string
string intToBinary(int num, int bit_size) {
    return bitset<8>(num).to_string().substr(8 - bit_size, bit_size);
}

int main() {
    string bin_dividend, bin_divisor;

    cout << "Enter dividend (binary): ";
    cin >> bin_dividend;
    cout << "Enter divisor (binary): ";
    cin >> bin_divisor;

    int dividend = binaryToInt(bin_dividend);
    int divisor = binaryToInt(bin_divisor);

    auto result = binaryDivision(dividend, divisor);

    cout << "\nInteger Quotient: " << result.first << endl;
    cout << "Binary Quotient: " << intToBinary(result.first, 8) << endl;

    cout << "Integer Remainder: " << result.second << endl;
    cout << "Binary Remainder: " << intToBinary(result.second, 8) << endl;

    return 0;
}

4)Enter a number: 538453
The number of threes in the given number is: 2
.data
    msg_prompt: .asciiz "Enter a number: "
    count_msg: .asciiz "The number of threes in the given number is: "
    newline: .asciiz "\n"

.text
    .globl main
main:
    # Prompt user for input
    li $v0, 4
    la $a0, msg_prompt
    syscall

    li $v0, 5   # Read user input (integer)
    syscall
    move $t0, $v0  # Store user input in $t0

    li $t1, 3      # Digit to count
    li $t2, 0       # Counter

count_loop:
    beq $t0, $zero, display_result   # If number == 0, stop
    div $t3, $t0, 10     # Get last digit
    mfhi $t4             # Get remainder (last digit)

    beq $t4, $t1, increment_count   # If last digit == 3, count it
    
    j remove_digit

increment_count:
    addi $t2, $t2, 1     # Increment count

remove_digit:
    div $t0, $t0, 10     # Remove last digit
    j count_loop

display_result:
    li $v0, 4
    la $a0, count_msg
    syscall

    li $v0, 1            # Print count
    move $a0, $t2
    syscall

    li $v0, 4
    la $a0, newline
    syscall

    li $v0, 10           # Exit program
    syscall

5)square(function)
.data
     msg1: .asciiz "Enter any number: "            #input message
     msg2: .asciiz "Square of the number is: "     #output message
     
.text
     #input message
      la $a0,msg1
      li $v0,4
      syscall
     
     #Taking integer input
      li $v0,5  
      syscall
      move $t0,$v0
      
     jal Square   #Jump and Link to Square function
     
     #Terminating the program
       li $v0,10
       syscall
Square:
       mul $t1,$t0,$t0
   
       #Output message
        la $a0,msg2
        li $v0,4
        syscall
       
       #Printing square of the number
        move $a0,$t1
        li $v0,1
        syscall
       
       jr $ra

6)Divisor
.data
prompt:     .asciiz "Enter an integer: "
div_msg:    .asciiz "Divisors: "
comma:      .asciiz ", "
newline:    .asciiz "\n"

.text
.globl main

main:
    # Prompt user
    li $v0, 4
    la $a0, prompt
    syscall

    # Read integer
    li $v0, 5
    syscall
    move $a1, $v0       # Save input in $a1 (used as argument to function)

    # Print "Divisors: "
    li $v0, 4
    la $a0, div_msg
    syscall

    # Call function
    jal print_divisors

    # Print newline
    li $v0, 4
    la $a0, newline
    syscall

    # Exit
    li $v0, 10
    syscall

# -------------------------------
# Function: print_divisors
# Input: $a1 = input number
# -------------------------------
print_divisors:
    move $t1, $a1       # $t1 = number
    li $t0, 1           # $t0 = i (counter)
    li $t2, 0           # $t2 = first_flag

div_loop:
    bgt $t0, $t1, end_divs   # while i <= n

    move $t3, $t1       # $t3 = n
    div $t3, $t0
    mfhi $t4            # remainder
    bnez $t4, not_div   # skip if not divisible

    # If not first, print comma
    bnez $t2, print_comma

skip_comma:
    move $a0, $t0       # prepare number to print
    li $v0, 1           # syscall: print integer
    syscall

    li $t2, 1           # mark that at least one divisor printed
    j continue_loop

print_comma:
    li $v0, 4
    la $a0, comma
    syscall
    j skip_comma

not_div:
    # skip

continue_loop:
    addi $t0, $t0, 1
    j div_loop

end_divs:
    jr $ra


7)Prime(function)
.data
    msg_input:      .asciiz "Enter a number: "
    msg_prime:      .asciiz "The number is PRIME.\n"
    msg_not_prime:  .asciiz "The number is NOT PRIME.\n"

.text
.globl main

main:
    # Prompt user for input
    li $v0, 4
    la $a0, msg_input
    syscall

    # Read user input
    li $v0, 5
    syscall
    move $a0, $v0       # Move input number to $a0 (argument for function)

    # Call is_prime function
    jal is_prime

    # Check return value in $v0
    beq $v0, $zero, print_not_prime
    j print_prime

print_not_prime:
    li $v0, 4
    la $a0, msg_not_prime
    syscall
    j exit

print_prime:
    li $v0, 4
    la $a0, msg_prime
    syscall
    j exit

exit:
    li $v0, 10
    syscall

# Function: is_prime
# Input : $a0 = number
# Output: $v0 = 1 (prime), 0 (not prime)

is_prime:
    move $t0, $a0       # $t0 = number
    li $t1, 2           # $t1 = divisor (starts from 2)

    # If number <= 1, not prime
    li $t4, 1
    ble $t0, $t4, not_prime_func

check_loop:
    mul $t5, $t1, $t1   # $t5 = divisor^2
    bgt $t5, $t0, prime_func  # if divisor^2 > number, it's prime

    div $t0, $t1        # divide number by divisor
    mfhi $t2            # get remainder

    beq $t2, $zero, not_prime_func  # divisible => not prime

    addi $t1, $t1, 1    # divisor++
    j check_loop

not_prime_func:
    li $v0, 0
    jr $ra

prime_func:
    li $v0, 1
    jr $ra

8)Reverse
.data
    prompt:         .asciiz "Enter a number: "
    resultMsg:      .asciiz "Reversed number: "
    inputBuffer:    .space 20
    reversedBuffer: .space 20

.text
.globl main

main:
    # Prompt for input
    li $v0, 4
    la $a0, prompt
    syscall

    # Read string input
    li $v0, 8
    la $a0, inputBuffer
    li $a1, 20
    syscall

    # Call reverse_string(inputBuffer, reversedBuffer)
    la $a0, inputBuffer      # arg1 = input string
    la $a1, reversedBuffer   # arg2 = output (reversed) string
    jal reverse_string       # call function

    # Print result
    li $v0, 4
    la $a0, resultMsg
    syscall

    li $v0, 4
    la $a0, reversedBuffer
    syscall

    # Exit
    li $v0, 10
    syscall

# --------------------------------------------
# Procedure: reverse_string
# Arguments:
#   $a0 = address of input string
#   $a1 = address of output buffer
# --------------------------------------------
reverse_string:
    # Save return address
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    # Find length of input string
    move $t0, $a0          # $t0 = input pointer
    li $t1, 0              # $t1 = length counter

count_loop:
    lb $t2, 0($t0)
    beq $t2, 10, done_count   # Stop at newline
    beqz $t2, done_count      # Or null character
    addi $t0, $t0, 1
    addi $t1, $t1, 1
    j count_loop

done_count:
    # $t1 = length of input (excluding newline)
    add $t3, $a0, $t1     # $t3 = pointer to end of input
    move $t4, $a1         # $t4 = output pointer

reverse_loop:
    addi $t3, $t3, -1
    lb $t5, 0($t3)
    sb $t5, 0($t4)
    addi $t4, $t4, 1
    addi $t1, $t1, -1
    bgtz $t1, reverse_loop

    # Null-terminate output string
    li $t6, 0
    sb $t6, 0($t4)

    # Restore return address and return
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra


9)sum even and odd(1-20)
.data
    evenMsg:   .asciiz "Sum of even numbers: "
    oddMsg:    .asciiz "Sum of odd numbers: "
    
.text
.globl main

main:
    li $t0, 1          # i = 1
    li $t1, 0          # even sum
    li $t2, 0          # odd sum

loop:
    bgt $t0, 20, done  # if i > 20, exit loop

    # check if even: if i % 2 == 0
    rem $t3, $t0, 2
    beq $t3, $zero, add_even

    # else it's odd
    add $t2, $t2, $t0   # odd sum += i
    j next

add_even:
    add $t1, $t1, $t0   # even sum += i

next:
    addi $t0, $t0, 1    # i++
    j loop

done:
    # print even sum
    li $v0, 4
    la $a0, evenMsg
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    # print newline
    li $v0, 11
    li $a0, 10
    syscall

    # print odd sum
    li $v0, 4
    la $a0, oddMsg
    syscall

    li $v0, 1
    move $a0, $t2
    syscall

    # exit
    li $v0, 10
    syscall


10)Length
.data
    prompt: .asciiz "Enter an integer: "
    result: .asciiz "Number of digits: "
    newline: .asciiz "\n"
    input:  .space 20

.text
.globl main

main:
    # Prompt
    li $v0, 4
    la $a0, prompt
    syscall

    # Read string
    li $v0, 8
    la $a0, input
    li $a1, 20
    syscall

    # Call function to count digits
    la $a0, input
    jal count_digits_string
    move $t1, $v0      # save result

    # Print message
    li $v0, 4
    la $a0, result
    syscall

    # Print digit count
    li $v0, 1
    move $a0, $t1
    syscall

    # Newline
    li $v0, 4
    la $a0, newline
    syscall

    li $v0, 10
    syscall

# Function: count_digits_string
# Input:  $a0 = address of string
# Output: $v0 = digit count
count_digits_string:
    li $t0, 0          # count
count_loop:
    lb $t1, 0($a0)     # load byte
    beq $t1, 10, done  # stop at newline (Enter key)
    beqz $t1, done     # null terminator
    addi $t0, $t0, 1
    addi $a0, $a0, 1
    j count_loop

done:
    move $v0, $t0
    jr $ra
 

11)even number array
.data
array: .space 2000            # 2000 bytes space for integer array
space: .asciiz " "
howMany: .asciiz "Enter the number of integers: "
inputMsg: .asciiz "Enter the elements of array :-\n"
outputMsg: .asciiz "Even numbers in the array: "

.text
.globl main

main:
    # print prompt for number of integers
    li $v0, 4
    la $a0, howMany
    syscall

    # read number of integers (n)
    li $v0, 5
    syscall
    move $s1, $v0          # s1 = n

    mul $s1, $s1, 4        # multiply by 4 to convert count to bytes for addressing

    # print input message
    li $v0, 4
    la $a0, inputMsg
    syscall

    addi $s0, $zero, 0     # s0 = 0 (offset/index in bytes)

inputLoop:
    beq $s0, $s1, output   # if offset == n*4, done input

    # take input integer
    li $v0, 5
    syscall
    move $t1, $v0

    # store input in array at offset s0
    sw $t1, array($s0)

    addi $s0, $s0, 4       # s0 += 4 (next int offset)
    j inputLoop

output:
    # print output message
    li $v0, 4
    la $a0, outputMsg
    syscall

    addi $s0, $zero, 0     # reset index for printing

printLoop:
    beq $s0, $s1, exit     # if offset == n*4, done printing

    lw $t4, array($s0)     # load word from array

    # check if even: (num % 2 == 0) using bitwise AND
    andi $t5, $t4, 1       # $t5 = $t4 & 1 (lowest bit)
    bne  $t5, $zero, skip_print

    # print integer (even number)
    li $v0, 1
    move $a0, $t4
    syscall

    # print space
    li $v0, 4
    la $a0, space
    syscall

skip_print:
    addi $s0, $s0, 4       # s0 += 4 (next element)
    j printLoop

exit:
    # exit program
    li $v0, 10
    syscall

12)arry-print
.data
	array: .space 2000 #2000 bytes
	space: .asciiz " "
	howMany: .asciiz "Enter the number of integer less than 500: "
	inputMsg: .asciiz "Enter the element of array :-\n"
	outputMsg: .asciiz "Array: "
.text
main:
	#print the string stored in howMany
	li $v0, 4
	la $a0, howMany
	syscall
	
	#Define the number of integers that should be input
	li $v0, 5
	syscall
	move $s1, $v0 #s1=5 integers
	
	mul $s1,$s1,4 # s1=20 bytes

	#print the string stored in howMany
	li $v0, 4
	la $a0, inputMsg
	syscall
	addi $s0, $zero, 0

inputLoop:
	beq $s0, $s1, output
	#take input form user
	li $v0, 5
	syscall
	move $t1, $v0
	
#store value in array
	sw $t1, array($s0) # array[0]=$t1    0,4,8,12,16,20
	addi $s0, $s0,4
	j inputLoop
output:
	li $v0, 4
	la $a0, outputMsg
	syscall
	
	addi $s0,$zero,0
printLoop:
	beq $s0, $s1, exit
	lw $t4, array($s0)
	#print the instant array position value
	li $v0, 1 #printing an integer
	move $a0, $t4
	syscall
	#print a space after a number
	li $v0, 4
	la $a0, space
	syscall
	#increment like i++
	addi, $s0, $s0,4
	j printLoop
exit:
	li $v0, 10
	syscall

13)odd
.data
array: .space 2000            # 2000 bytes space for integer array
space: .asciiz " "
howMany: .asciiz "Enter the number of integers: "
inputMsg: .asciiz "Enter the elements of array :-\n"
outputMsg: .asciiz "Odd numbers in the array: "

.text
.globl main

main:
    # print prompt for number of integers
    li $v0, 4
    la $a0, howMany
    syscall

    # read number of integers (n)
    li $v0, 5
    syscall
    move $s1, $v0          # s1 = n

    mul $s1, $s1, 4        # multiply by 4 to convert count to bytes for addressing

    # print input message
    li $v0, 4
    la $a0, inputMsg
    syscall

    addi $s0, $zero, 0     # s0 = 0 (offset/index in bytes)

inputLoop:
    beq $s0, $s1, output   # if offset == n*4, done input

    # take input integer
    li $v0, 5
    syscall
    move $t1, $v0

    # store input in array at offset s0
    sw $t1, array($s0)

    addi $s0, $s0, 4       # s0 += 4 (next int offset)
    j inputLoop

output:
    # print output message
    li $v0, 4
    la $a0, outputMsg
    syscall

    addi $s0, $zero, 0     # reset index for printing

printLoop:
    beq $s0, $s1, exit     # if offset == n*4, done printing

    lw $t4, array($s0)     # load word from array

    # check if odd: (num % 2 == 1) using bitwise AND
    andi $t5, $t4, 1       # $t5 = $t4 & 1 (lowest bit)
    beq $t5, $zero, skip_print  # if lowest bit == 0, skip (means even)

    # print integer (odd number)
    li $v0, 1
    move $a0, $t4
    syscall

    # print space
    li $v0, 4
    la $a0, space
    syscall

skip_print:
    addi $s0, $s0, 4       # s0 += 4 (next element)
    j printLoop

exit:
    # exit program
    li $v0, 10
    syscall


14)odd+count
.data
array: .space 2000            # 2000 bytes space for integer array
space: .asciiz " "
howMany: .asciiz "Enter the number of integers: "
inputMsg: .asciiz "Enter the elements of array :-\n"
outputMsg: .asciiz "Odd numbers in the array: "
countMsg: .asciiz "\nTotal odd numbers: "

.text
.globl main

main:
    # print prompt for number of integers
    li $v0, 4
    la $a0, howMany
    syscall

    # read number of integers (n)
    li $v0, 5
    syscall
    move $s1, $v0          # s1 = n

    mul $s1, $s1, 4        # convert n to bytes (for offset)

    # print input message
    li $v0, 4
    la $a0, inputMsg
    syscall

    addi $s0, $zero, 0     # offset = 0

inputLoop:
    beq $s0, $s1, output   # if offset == n*4, done input

    # input integer
    li $v0, 5
    syscall
    move $t1, $v0

    # store in array
    sw $t1, array($s0)

    addi $s0, $s0, 4       # offset += 4
    j inputLoop

output:
    # print odd numbers message
    li $v0, 4
    la $a0, outputMsg
    syscall

    addi $s0, $zero, 0     # offset = 0
    addi $t6, $zero, 0     # t6 = odd count = 0

printLoop:
    beq $s0, $s1, printCount  # if offset == n*4, done printing

    lw $t4, array($s0)

    # check odd
    andi $t5, $t4, 1
    beq $t5, $zero, skip_print

    # print odd number
    li $v0, 1
    move $a0, $t4
    syscall

    # print space
    li $v0, 4
    la $a0, space
    syscall

    # increment odd count
    addi $t6, $t6, 1

skip_print:
    addi $s0, $s0, 4
    j printLoop

printCount:
    # print newline for neatness
    li $v0, 4
    la $a0, space
    syscall

    # print total odd numbers message
    li $v0, 4
    la $a0, countMsg
    syscall

    # print odd count (t6)
    li $v0, 1
    move $a0, $t6
    syscall

exit:
    li $v0, 10
    syscall

15)Avg
.data
array:      .space 400       # 100 integers space
prompt_n:   .asciiz "Enter number of elements: "
prompt_el:  .asciiz "Enter array elements:\n"
msg_sum:    .asciiz "Sum = "
msg_avg:    .asciiz "Average = "

.text
.globl main

main:
    # Prompt for n
    li $v0, 4
    la $a0, prompt_n
    syscall

    # Read n (number of elements)
    li $v0, 5
    syscall
    move $s1, $v0          # s1 = n

    # Prompt for elements
    li $v0, 4
    la $a0, prompt_el
    syscall

    li $s0, 0              # index = 0
input_loop:
    beq $s0, $s1, calc_sum

    # Read one integer
    li $v0, 5
    syscall
    move $t0, $v0

    sll $t1, $s0, 2        # offset = index*4
    sw $t0, array($t1)

    addi $s0, $s0, 1
    j input_loop

calc_sum:
    li $s0, 0
    li $t2, 0              # sum = 0

sum_loop:
    beq $s0, $s1, print_sum_avg

    sll $t1, $s0, 2
    lw $t0, array($t1)
    addu $t2, $t2, $t0

    addi $s0, $s0, 1
    j sum_loop

print_sum_avg:
    # print sum message
    li $v0, 4
    la $a0, msg_sum
    syscall

    # print sum integer
    li $v0, 1
    move $a0, $t2
    syscall

    # print newline
    li $v0, 11
    li $a0, 10
    syscall

    # Convert sum (int) to float in $f12
    mtc1 $t2, $f0           # move sum to $f0 (int)
    cvt.s.w $f12, $f0       # convert int to float in $f12

    # Convert n (int) to float in $f14
    mtc1 $s1, $f2
    cvt.s.w $f14, $f2

    # floating point division: $f12 = sum(float) / n(float)
    div.s $f12, $f12, $f14

    # print avg message
    li $v0, 4
    la $a0, msg_avg
    syscall

    # print average (float) in $f12
    mov.s $f0, $f12
    li $v0, 2
    syscall

    # print newline
    li $v0, 11
    li $a0, 10
    syscall

    # exit
    li $v0, 10
    syscall

16) swap
.data
num1_msg: .asciiz "Enter first number: "
num2_msg: .asciiz "Enter second number: "
after_first_msg: .asciiz "After swap first number: "
after_second_msg: .asciiz " after swap second number "
newline: .asciiz "\n"

.text
.globl main

main:
    # Read first number
    li $v0, 4
    la $a0, num1_msg
    syscall

    li $v0, 5
    syscall
    move $s0, $v0        # num1 in $s0

    # Read second number
    li $v0, 4
    la $a0, num2_msg
    syscall

    li $v0, 5
    syscall
    move $s1, $v0        # num2 in $s1

    # Call swap function
    move $a0, $s0
    move $a1, $s1
    jal swap_numbers

    move $s0, $v0        # swapped first number
    move $s1, $v1        # swapped second number

    # Print "After swap first number: "
    li $v0, 4
    la $a0, after_first_msg
    syscall

    # Print swapped first number
    li $v0, 1
    move $a0, $s0
    syscall

    # Print " after swap second number "
    li $v0, 4
    la $a0, after_second_msg
    syscall

    # Print swapped second number
    li $v0, 1
    move $a0, $s1
    syscall

    # Print newline
    li $v0, 4
    la $a0, newline
    syscall

    # Exit
    li $v0, 10
    syscall

# Swap function: swaps $a0 and $a1, returns swapped values in $v0 and $v1
swap_numbers:
    addi $sp, $sp, -8
    sw $ra, 4($sp)
    sw $s0, 0($sp)

    move $s0, $a0

    move $v0, $a1
    move $v1, $s0

    lw $ra, 4($sp)
    lw $s0, 0($sp)
    addi $sp, $sp, 8
    jr $ra


17)factorial
.data
prompt: .asciiz "Enter a number: "
resultMsg: .asciiz "Factorial = "

.text
.globl main

main:
    # Print prompt
    li $v0, 4
    la $a0, prompt
    syscall

    # Read integer input
    li $v0, 5
    syscall
    move $a0, $v0  # Store input in $a0

    # Check for negative input (factorial is undefined for negative numbers)
    bltz $a0, exit

    # Call factorial function
    jal factorial
    move $s1, $v0  # Store result in $s1

    # Print result message
    li $v0, 4
    la $a0, resultMsg
    syscall

    # Print factorial value
    li $v0, 1
    move $a0, $s1
    syscall

exit:
    # Exit program
    li $v0, 10
    syscall


# Function: factorial
# Arguments:
#   $a0 = input number
# Returns:
#   $v0 = factorial result
factorial:
    addi $sp, $sp, -8       # Allocate stack space
    sw $ra, 4($sp)          # Save return address
    sw $a0, 0($sp)          # Save input number

    li $v0, 1               # Base case: factorial(0) = 1
    blez $a0, end_factorial # If input <= 0, return 1

    # Recursive case: n * factorial(n - 1)
    addi $a0, $a0, -1       # Decrement n
    jal factorial           # Recursive call
    lw $a0, 0($sp)          # Restore original input
    mul $v0, $a0, $v0       # Multiply n * factorial(n - 1)

end_factorial:
    lw $ra, 4($sp)          # Restore return address
    addi $sp, $sp, 8        # Restore stack
    jr $ra                  # Return


18)Palindrom
.data
msg: .asciiz "Enter any number: "
yesMsg: .asciiz "This is a palindrome number.\n"
noMsg: .asciiz "This is not a palindrome number.\n"

.text
.globl main

main:
    # Print message prompt
    li $v0, 4
    la $a0, msg
    syscall

    # Read integer input
    li $v0, 5
    syscall
    move $a0, $v0  # Store input in $a0

    # Call check_palindrome function
    jal check_palindrome
    move $t5, $v0  # Store result in $t5

    # Print corresponding result message
    li $v0, 4
    la $a0, yesMsg
    beq $t5, 1, printResult  # If palindrome, print "Yes"
    
    la $a0, noMsg            # Otherwise, print "No"

printResult:
    syscall

exit:
    # Exit program
    li $v0, 10
    syscall

# Function: check_palindrome
# Arguments:
#   $a0 = input number
# Returns:
#   $v0 = 1 (if palindrome), 0 (if not palindrome)
check_palindrome:
    addi $sp, $sp, -12     # Allocate stack space
    sw $ra, 8($sp)         # Save return address
    sw $a0, 4($sp)         # Save original input
    sw $zero, 0($sp)       # Initialize reversed number ($t4)

    move $t1, $a0          # Copy input to process reversing
    li $t4, 0              # Initialize reversed number

reverseLoop:
    beq $t1, $zero, compare  # If input is fully processed, check result

    rem $t3, $t1, 10        # Get last digit
    mul $t4, $t4, 10        # Shift previous digits left
    add $t4, $t4, $t3       # Append last digit
    div $t1, $t1, 10        # Remove last digit

    j reverseLoop           # Continue reversing

compare:
    lw $t1, 4($sp)          # Restore original input
    beq $t1, $t4, palindrome # If original == reversed, set return value to 1

    li $v0, 0               # Not a palindrome
    j returnFunction

palindrome:
    li $v0, 1               # It is a palindrome

returnFunction:
    lw $ra, 8($sp)          # Restore return address
    addi $sp, $sp, 12       # Restore stack
    jr $ra                  # Return

19)Fibonnaci
.data
msg: .asciiz "Enter the number of terms: "
resultMsg: .asciiz "Fibonacci Sequence: "
space: .asciiz " "

.text
.globl main

main:
    # Print prompt message
    li $v0, 4
    la $a0, msg
    syscall

    # Read number of terms
    li $v0, 5
    syscall
    move $s1, $v0          # Store count in $s1

    # Validate input
    blez $s1, exit         # If input <= 0, exit program

    # Print result message
    li $v0, 4
    la $a0, resultMsg
    syscall

    # Initialize Fibonacci variables
    li $t0, 0              # First term
    li $t1, 1              # Second term

    # Print first term
    li $v0, 1
    move $a0, $t0
    syscall

    # Print space
    li $v0, 4
    la $a0, space
    syscall

    # Check if only one term needed
    beq $s1, 1, exit

    # Print second term
    li $v0, 1
    move $a0, $t1
    syscall

    # Print space
    li $v0, 4
    la $a0, space
    syscall

    # Loop to calculate Fibonacci sequence
    li $s0, 2              # Start index at 2
fiboLoop:
    beq $s0, $s1, exit     # If count reached, exit

    add $t2, $t0, $t1      # Next Fibonacci term
    move $t0, $t1          # Shift values
    move $t1, $t2

    # Print next term
    li $v0, 1
    move $a0, $t2
    syscall

    # Print space
    li $v0, 4
    la $a0, space
    syscall

    addi $s0, $s0, 1       # Increment count
    j fiboLoop

exit:
    # Exit program
    li $v0, 10
    syscall

20)Harshad number
.data
msg: .asciiz "Enter a number: "
yesMsg: .asciiz "It is a Harshad number.\n"
noMsg: .asciiz "It is not a Harshad number.\n"

.text
.globl main

main:
    # Print prompt message
    li $v0, 4
    la $a0, msg
    syscall

    # Read integer input
    li $v0, 5
    syscall
    move $a0, $v0  # Store input in $a0

    # Validate input (must be positive)
    blez $a0, exit # If input ≤ 0, exit program

    # Call harshad_check function
    jal harshad_check
    move $t5, $v0  # Store result in $t5

    # Print corresponding result message
    li $v0, 4
    la $a0, yesMsg
    beq $t5, 1, printResult  # If Harshad number, print "Yes"
    
    la $a0, noMsg            # Otherwise, print "No"

printResult:
    syscall

exit:
    # Exit program
    li $v0, 10
    syscall


# Function: harshad_check
# Arguments:
#   $a0 = input number
# Returns:
#   $v0 = 1 (if Harshad number), 0 (if not)

harshad_check:
    addi $sp, $sp, -12      # Allocate stack space
    sw $ra, 8($sp)          # Save return address
    sw $a0, 4($sp)          # Save original input
    sw $zero, 0($sp)        # Initialize sum of digits ($t4)

    move $t1, $a0           # Copy input to process sum
    li $t4, 0               # Initialize sum of digits

sumLoop:
    beq $t1, $zero, checkDivision  # If all digits are processed, check result

    rem $t3, $t1, 10        # Get last digit
    add $t4, $t4, $t3       # Add digit to sum
    div $t1, $t1, 10        # Remove last digit

    j sumLoop               # Continue summing digits

checkDivision:
    lw $t1, 4($sp)          # Restore original input
    rem $t2, $t1, $t4       # Compute original % sum of digits

    beq $t2, $zero, isHarshad  # If divisible, set return value to 1

    li $v0, 0               # Not a Harshad number
    j returnFunction

isHarshad:
    li $v0, 1               # It is a Harshad number

returnFunction:
    lw $ra, 8($sp)          # Restore return address
    addi $sp, $sp, 12       # Restore stack
    jr $ra                  # Return


21)Abundant_number
.data
msg: .asciiz "Enter a number: "
yesMsg: .asciiz "It is an abundant number.\n"
noMsg: .asciiz "It is not an abundant number.\n"

.text
.globl main

main:
    # Print prompt message
    li $v0, 4
    la $a0, msg
    syscall

    # Read integer input
    li $v0, 5
    syscall
    move $a0, $v0  # Store input in $a0

    # Validate input (must be positive)
    blez $a0, exit # If input ≤ 0, exit program

    # Call abundant_check function
    jal abundant_check
    move $t5, $v0  # Store result in $t5

    # Print corresponding result message
    li $v0, 4
    la $a0, yesMsg
    beq $t5, 1, printResult  # If abundant number, print "Yes"
    
    la $a0, noMsg            # Otherwise, print "No"

printResult:
    syscall

exit:
    # Exit program
    li $v0, 10
    syscall


# Function: abundant_check
# Arguments:
#   $a0 = input number
# Returns:
#   $v0 = 1 (if abundant number), 0 (if not)

abundant_check:
    addi $sp, $sp, -12      # Allocate stack space
    sw $ra, 8($sp)          # Save return address
    sw $a0, 4($sp)          # Save original input
    sw $zero, 0($sp)        # Initialize sum of divisors ($t4)

    li $t1, 1               # Start divisor at 1
    li $t4, 0               # Initialize sum of divisors

divisorLoop:
    beq $t1, $a0, checkAbundance  # If all divisors checked, verify result

    rem $t3, $a0, $t1       # Check if divisible
    bne $t3, $zero, skipDivisor # If not a divisor, skip

    add $t4, $t4, $t1       # Add divisor to sum

skipDivisor:
    addi $t1, $t1, 1        # Increment divisor
    j divisorLoop           # Continue checking

checkAbundance:
    lw $t1, 4($sp)          # Restore original input
    bgt $t4, $t1, isAbundant  # If sum of divisors > number, set return value to 1

    li $v0, 0               # Not an abundant number
    j returnFunction

isAbundant:
    li $v0, 1               # It is an abundant number

returnFunction:
    lw $ra, 8($sp)          # Restore return address
    addi $sp, $sp, 12       # Restore stack
    jr $ra                  # Return

22)
 
